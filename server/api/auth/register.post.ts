import type { User } from '#auth-utils'
import { User as UserModel } from '~~/server/models/User'

function generateEmail(firstName: string, lastName: string, phone: string): string {
  const cleanFirstName = firstName.toLowerCase().replace(/[^a-z]/g, '')
  const cleanLastName = lastName.toLowerCase().replace(/[^a-z]/g, '')
  
  const phoneSuffix = phone.slice(-4)

  const emailOptions = [
    `${cleanFirstName}.${cleanLastName}${phoneSuffix}@amaam.app`,
    `${cleanFirstName}${cleanLastName}${phoneSuffix}@amaam.app`,
    `${cleanFirstName}_${cleanLastName}${phoneSuffix}@amaam.app`,
    `${cleanFirstName}${phoneSuffix}@amaam.app`,
  ]
  
  return emailOptions[0]
}

export default defineEventHandler(async (event) => {
  await clearUserSession(event)

  const body = await readBody(event)
  const { phone, password, role, email } = body

  try {
    const existingUser = await UserModel.findOne({ phone })

    if (existingUser) {
      return createError({
        statusCode: 400,
        statusMessage: 'User with this phone number already exists',
      })
    }

    const hashedPassword = await hashPassword(password)

    // Auto-generate email if not provided
    const firstName = body.first_name || 'user'
    const lastName = body.last_name || 'unknown'
    const autoGeneratedEmail = email || generateEmail(firstName, lastName, phone)

    // Check if generated email already exists and make it unique if needed
    let finalEmail = autoGeneratedEmail
    let emailExists = await UserModel.findOne({ email: finalEmail })
    let counter = 1

    while (emailExists) {
      const emailParts = autoGeneratedEmail.split('@')
      finalEmail = `${emailParts[0]}${counter}@${emailParts[1]}`
      emailExists = await UserModel.findOne({ email: finalEmail })
      counter++
    }

    const newUser = await UserModel.create({
      email: finalEmail,
      password: hashedPassword,
      first_name: firstName,
      last_name: lastName,
      role: role || 'normal',
      phone,
      isActive: true,
      isVerified: false,
      lastLogin: null,
    })


    const [dbUser] = await UserModel.aggregate([
      {
        $match: { _id: newUser._id },
      },
      {
        $lookup: {
          from: 'properties',
          localField: 'ownedProperties',
          foreignField: '_id',
          as: 'ownedPropertiesData',
          pipeline: [
            {
              $project: {
                _id: 1,
                propertyName: 1,
                categoryName: 1,
                logo: 1,
                address: 1,
              },
            },
          ],
        },
      },
      {
        $lookup: {
          from: 'properties',
          localField: 'assignedProperty',
          foreignField: '_id',
          as: 'assignedPropertyData',
          pipeline: [
            {
              $project: {
                _id: 1,
                propertyName: 1,
                categoryName: 1,
                logo: 1,
                address: 1,
              },
            },
          ],
        },
      },
      {
        $lookup: {
          from: 'units',
          localField: 'ownedUnits',
          foreignField: '_id',
          as: 'ownedUnitsData',
          pipeline: [
            {
              $lookup: {
                from: 'properties',
                localField: 'propertyId',
                foreignField: '_id',
                as: 'property',
                pipeline: [
                  {
                    $project: {
                      _id: 1,
                      propertyName: 1,
                      categoryName: 1,
                      logo: 1,
                      address: 1,
                    },
                  },
                ],
              },
            },
            {
              $unwind: '$property',
            },
          ],
        },
      },
      {
        $lookup: {
          from: 'units',
          localField: 'rentedUnits',
          foreignField: '_id',
          as: 'rentedUnitsData',
          pipeline: [
            {
              $lookup: {
                from: 'properties',
                localField: 'propertyId',
                foreignField: '_id',
                as: 'property',
                pipeline: [
                  {
                    $project: {
                      _id: 1,
                      propertyName: 1,
                      categoryName: 1,
                      logo: 1,
                      address: 1,
                    },
                  },
                ],
              },
            },
            {
              $unwind: '$property',
            },
          ],
        },
      },
    ])

    // Extract properties based on user role
    let properties: any[] = []

    if (dbUser.role === 'developer') {
      properties = dbUser.ownedPropertiesData || []
    }
    else if (dbUser.role === 'caretaker') {
      properties = dbUser.assignedPropertyData || []
    }
    else if (dbUser.role === 'unit_owner' || dbUser.role === 'tenant') {
      const unitProperties = [
        ...(dbUser.ownedUnitsData?.map((unit: any) => unit.property) || []),
        ...(dbUser.rentedUnitsData?.map((unit: any) => unit.property) || []),
      ]

      const uniquePropertiesMap = new Map()
      unitProperties.forEach((prop) => {
        if (prop && prop._id) {
          uniquePropertiesMap.set(prop._id.toString(), prop)
        }
      })
      properties = Array.from(uniquePropertiesMap.values())
    }

    const formattedProperties = properties.map(property => ({
      id: property._id.toString(),
      name: property.propertyName,
      logo: property.logo || null,
      address: `${property.address.street}, ${property.address.city}, ${property.address.state} ${property.address.postalCode}`,
    }))

    const user: User = {
      _id: dbUser._id.toString(),
      first_name: dbUser.first_name || '',
      last_name: dbUser.last_name || '',
      email: dbUser.email || '',
      role: dbUser.role,
      phone: dbUser.phone || '',
      createdAt: dbUser.createdAt,
      updatedAt: dbUser.updatedAt,
      lastLogin: dbUser.lastLogin,
      isActive: dbUser.isActive,
      isVerified: dbUser.isVerified,
      address: dbUser.address,
      ownedProperties: dbUser.ownedProperties || [],
      ownedUnits: dbUser.ownedUnits || [],
      rentedUnits: dbUser.rentedUnits || [],
      assignedProperty: dbUser.assignedProperty || null,
      tempPasswordExpiry: dbUser.tempPasswordExpiry || null,
      tempPasswordUsed: dbUser.tempPasswordUsed || false,
      tempPasswordVerifiedAt: dbUser.tempPasswordVerifiedAt || null,
      properties: formattedProperties,
    }

    await setUserSession(event, {
      user,
      loggedInAt: new Date(),
    })

    return await getUserSession(event)
  }
  catch (error) {
    console.error('Registration error:', error)

    return createError({
      statusCode: 500,
      statusMessage: 'An error occurred during registration',
    })
  }
})